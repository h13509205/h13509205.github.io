<!DOCTYPE html> <html lang="en" class="no-js"> <head> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>52saber</title> <meta name="description" content="Personal Blog" /> <meta name="keywords" content="Learning" /> <meta name="author" content="hwt" /> <link rel="shortcut icon" href="img/favicon.ico"> <link rel="stylesheet" type="text/css" href="css/normalize.css" /> <link rel="stylesheet" type="text/css" href="fonts/font-awesome-4.3.0/css/font-awesome.min.css" /> <link rel="stylesheet" type="text/css" href="css/modern-blog.min.css" /> <!--[if IE]> <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script> <![endif]--> <script> if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) { var root = document.getElementsByTagName('html')[0]; root.setAttribute('class', 'ff'); }; </script> </head> <body class="body"> <div class="container"> <header class="header"> <h1>Saber<span>个人学习博客.</span></h1> </header> <div class="content"> <!-- trianglify pattern container --> <div class="pattern pattern--hidden"></div> <!-- cards --> <div class="wrapper"> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id=""> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#)" width="1920" height="1200" xlink:href="img/20160409.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">对于manacher算法的一些思考</h2> <p class="card__subtitle"></p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Apr 8, 2016</span> </div> <h4 id="section">一些看法</h4> <p>网上也看了一些manacher的实现，感觉实现起来有点难，自己写代码的时候也有点磕磕绊绊。</p> <p>这个算法主要思想就是使用更大的容量，将计算回文需要考虑的回文长度的奇偶性全部处理为只要考虑奇数长度的。<br /> 如回文<code class="highlighter-rouge">abba</code> 将其扩充为 <code class="highlighter-rouge">#a#b#b#a#</code> ，这样就只考虑奇数长度的回文即可。<br /> 计算得到扩充后字符串中以每个字符为中点的最大回文长度半径（包括自身）为<code class="highlighter-rouge">[1, 2, 1, 2, 5, 2, 1, 2, 1]</code> ,将其全部减一之后就是以该点为中点， 得到的最长回文字串。<br /> 当然我们还可以使用之前计算好的值， 来保证这个算法的时间复杂度为O(n)时间<br /> 如果我们知道了上一个能够覆盖到最远距离的字符， 那么我们就能知道这个最远距离能够覆盖到字符串的第right位，<br /> 而且我们可以知道这个最远的字符在字符串的第idx位，</p> <p>1.那么我们在求第i个字符的最大回文长度的时候（i &gt; idx），我们就可以知道这个时候最短的回文长度和2*idx-i这个点（和idx对称的那个点）的一样长<br /> 2.如果由对称点推断出的i的最短回文长度无法覆盖到right时，我们就可以知道i点的最大回文长度就为其对称点的最大回文长度；<br /> 3.如果i点可以覆盖到right时，说明最大回文长度可能更长，<br /> 4.如果更长，那么新的idx就为当前点i，right也重新更新为新的right点，<br /> 5.如果没有更长，那么i点的最大回文长度就为其对称点的最大回文长度，不跟新idx与right（选择覆盖范围最大的，包含right的idx）<br /> 6.计算下一个i+1的最长回文长度</p> <p>这样保证了在所有循环计算点i的最大回文长度时，每个right点只被计算了1次，其他也没有影响效率的操作了，可以得出O(n)的时间复杂度。<br /> 下面贴出我写的萌萌哒代码（和网上的不太一样，别人的更简练，我这个思路还算清晰）</p><pre><code>  
public int[] helper(String ss) {  
    	int[] ans = new int[ss.length()];  
    	ans[0] = 1;  
    	int id = 0;  
    	int right = 0;  
    	for(int i = 1; i &lt; ans.length; i++) {  
    		int radius = 1;  
    		if(i &lt; right &amp;&amp; ans[2*id-i]+i-1 &lt; right) {   
    			ans[i] = ans[2*id-i];  
    			continue;  
    		}else if(i &lt; right &amp;&amp; 2*id-i &gt;= 0 &amp;&amp; ans[2*id-i]+i-1 == right) {  
    			radius = ans[2*id-i];  
    		}  
    		while(i-radius &gt;= 0 &amp;&amp; i+radius &lt;ans.length &amp;&amp; ss.charAt(i+radius) == ss.charAt(i-radius)) {  
    			radius++;  
    		}    
    		ans[i] = radius;  
    		if(2*id-i &gt;= 0 &amp;&amp; radius == ans[2*id-i]) {  
    			continue;  
    		}  
    		right = i+radius-1;  
    		id = i;  
    	}  
    	return ans;  
    }  
</code></pre></div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="字符串操作"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#字符串操作)" width="1920" height="1200" xlink:href="img/20160329.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">leetcode总结篇1</h2> <p class="card__subtitle">字符串操作</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 29, 2016</span> </div> <h2 id="string">关于对String的问题总结</h2> <p>### 0 调整格式<br /> 下次不写那么长的了，jekyll的markdown解析器太弱了</p> <h3 id="section">1.（在满足一定条件下）最长/短子字符串问题</h3> <p>1.1 子字符串中没有重复的字符的最长子串<br /> 1.2 子字符串是个回文字符串的最长子串<br /> 1.3 子字符串是给定所有字符串的公共前缀的最长子串<br /> 1.4 子字符串满足括号的合法性的最长子串<br /> 1.5 子字符串包含所有给定字符的最短子串<br /> 1.6 以给定字符串为基础，构建最短回文字符串， 即该字符串中的一段为给定字符串</p> <h3 id="section-1">2.（在不同规则下）字符串的加减乘问题</h3> <p>2.1 字符串的相乘<br /> 2.2 字符串表示二进制加法<br /> 2.3 实现一个计算器，字符串给的是计算公式</p> <h3 id="section-2">3.字符串的转换问题</h3> <p>3.1 字符串转Integer（即实现atoi函数）<br /> 3.2 字符串和罗马数字的相互转换<br /> 3.3 字符串加密解密（简单映射）<br /> 3.4 数字转英文（转换后的为英语口语念这段数字）</p> <h3 id="section-3">4.字符串的重排序问题</h3> <p>4.1 把字符串按照‘之’字形进行排列<br /> 4.2 把一个字符串数组中的字符串按顺序放到许多行长度为L的空字符串中，字符串与字符串之间的空格数量要基本相同<br /> 4.3 反转字符串（全部反转，反转一部分，反转单词）</p> <h3 id="section-4">5.字符串匹配问题</h3> <p>5.1 正则表达式只包含“ . ” “ * ”两个字符<br /> 5.2 给定一个字典和一个字符串，找出字符串中某一段，与字典中的所有字符串都串起来相同<br /> 5.3 给定一个unix下的用字符串表示的路径，将其简化（其中可能有./ ../ ///）</p> <h3 id="section-5">6.字符串的排列组合问题</h3> <p>6.1 手机电话键盘输入的一串数字，有多少种字符的排列组合<br /> 6.2 给定一定数量的括号，有多少种括号的排列组合满足括号的合法性<br /> 6.3 把有同一个字符有相同数量的字符串整合到一个数组中<br /> 6.4 查看两个字符串的编辑距离是否为1（只修改1次就可以把一个字符串变为另一个字符串），或计算两个字符串的编辑距离<br /> 6.5 字符串内部顺序交换（87题） <br /> 6.6 给定一个ip（字符串表示，没有“.”），求可以表示多少种ip<br /> 6.7 两个字符串组成一个新的字符串，保证新字符串中的字符在原先字符串中的顺序不变<br /> 6.8 （和6.7类似）一个字符串，删掉一些字符，是否可以变成另一个字符串（有多少种删除方式）<br /> 6.9 给定两个字符串和一个字典，每次可以改变字符串的其中一个字母（但新改变的必须要在字典之中），几次（有几种方式）可以转变为目标字符串</p> <h3 id="section-6">7.杂项</h3> <p>7.1 字符串是否可以表示成一个数字（数字可能用科学记数法表示）<br /> 7.2 字符串是否是回文（其中某些字符不在判断之列，如空格）<br /> 7.3 对比用string表示的版本号</p> <h3 id="section-7">通用的字符串的处理方式</h3> <h3 id="section-8">1. 对回文的处理</h3> <p>一般来做也就是从中间向两边扩展的做法，但是还有一个manacher算法，可以用线性时间来计算每个点的最大回文长度，思想就是把最大回文长度从奇数或偶数全变为了奇数，再利用了之前的计算回文长度的信息，这样就保证在O(n)时间内计算得到所有点的最大回文长度。<br /> <a href="http://blog.csdn.net/xn4545945/article/details/38795531">计算回文4中方法总结</a><br /> <a href="http://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/">manacher算法1</a><br /> <a href="http://www.geeksforgeeks.org/longest-palindromic-substring-set-2/">manacher算法2</a></p> <h3 id="section-9">2. 字符串的加减乘除处理，和数字的合法性</h3> <p>2.1 首先要处理这个字符串是否能够表示成一个数字，有些可能在最前面有很多个0，那样是不合法的<br /> 2.2 接着要处理数字符号，+/-号，最后结果可能是-号<br /> 2.3 加法就要考虑当前相加位数和进位的数值，当这3个都为0，且超过了最大数的位数时才停止计算<br /> 2.4 乘法就是多个加法相加，感觉也没有其他什么好方法<br /> 2.5 给定一个计算公式来计算这个公式的值，那么不光需要记录当前的符号，也需要记录上一个符号，以及上一个数字， 这样当遇到当前符号优先级比上一个符号要高的时候，就回退。<br /> 比如我计算3+5<em>6</em>8，首先记录符号+，和相加之后的值8，和之前的一个操作数5，当下一个符号是<em>时，那么就回退， 得到之前符号+，相加值33，之前一个操作数30（5</em>6），乘号的话为优先级最高的符号，计算完之后可以不保留。<br /> 如果遇到括号，那么可以用递归的方式，把他丢到一个函数里去处理，最后返回这个括号里计算得到的值，这样处理可以 解决多个括号的问题。当然，在最开始需要验证括号是否都有匹配上。</p> <h3 id="section-10">3. 字符串转换</h3> <p>找规律，然后做映射</p> <h3 id="section-11">4. 字符串重排序</h3> <p>4.1 找规律，然后将source字符串放入target字符串<br /> 4.2 可以用贪心算法，每次在满足条件下，放入最多个字符串<br /> 4.3 一次旋转的话就直接交换对应字符所在位置，如果把abcdef旋转为defabc，那么可以使用3次旋转的方式对其做出改变，ba=(a’b’)’</p> <h3 id="section-12">5. 正则表达式匹配</h3> <p>不会好方法，正在学习</p> <h3 id="section-13">6. 字符串的排列组合</h3> <p>6.1 最直观的：backtracking，可以获得所有的排列组合，也可以用二进制来做，但是这样做会有重复， 6.2 edit distance编辑距离，使用动态规划会比较好做，之后在动态规划里再讲这个。（如72题）<br /> 6.3 一般两个字符串合成为另一个更长的字符串问题，可以使用双指针，一个指向字符串1的头，一个指向另一个字符串的头， 看哪个符合要求，就让那个字符串的指针向后移。<br /> 6.4 当字符串变化是，假如说一次只变化其中一个字符，一般用BFS来储存这个字符串到底能变成多少种其他字符串， 这样可以用最少的变化次数变为目标字符串。（如word ladder）<br /> 6.5 当判断组成两个字符串的字符是否相同时，1.可以用hashmap来做，2.可以将两个字符串排序，看其是否相同。</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id=""> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#)" width="1920" height="1200" xlink:href="img/20160323.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">阿里校招问题汇总!</h2> <p class="card__subtitle"></p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 23, 2016</span> </div> <h3 id="section">问题汇总</h3> <p>阿里校招电面难度还是有点高，作为一个为怎么好好学习java的人，问的一半问题我都没回答出来（或没回答好），本来想引导一下面试官，让他向基础的leetcode类型算法问，但是一个算法题都没问。</p> <ol> <li>自我介绍</li> <li>项目介绍</li> <li>项目中用的那些技术，你的工作部分是哪些</li> <li>ssh哪些模块，都用过哪些</li> <li>aop和ioc原理</li> <li>数据库引擎种类</li> <li>数据库引擎底层如何实现</li> <li>数据库索引种类及内部实现</li> <li>Hashmap底层实现</li> <li>堆栈溢出种类</li> <li>线程进程区别</li> <li>多线程如何死锁</li> <li>concurrent包看过哪些（concurrentHashMap）</li> <li>http协议报头组成</li> <li>斗鱼弹幕爬虫项目</li> <li>jvm垃圾回收算法</li> <li>分布式（直接说不会）</li> <li>struts和spring区别</li> </ol> <h1 id="section-1">03-24 更新2面</h1> <ol> <li>介绍一下自己遇到过，解决过最难的问题</li> <li>算法题<br /> 2.1 快速排序算法在最好的时间复杂度和最坏的时间复杂度 2.2 一个乱序数组，怎么知道其中两个数之和等于给定的值（O(n)时间，O(n)空间做法。。。O(nlogn)时间做法） 2.3 50个红球，50个白球，2个罐子（容量100），怎么放这些球，使得摸到红球的几率最大(数学题)。</li> <li>又问了一遍GC</li> <li>还有什么想问的（我把张浩在解决的那个bug问了他）。</li> </ol> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="翻译"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#翻译)" width="1920" height="1200" xlink:href="img/20160303.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Use MongoDB 3.2 in java</h2> <p class="card__subtitle">翻译</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 3, 2016</span> </div> <h3 id="mongodb-32-">MongoDB 3.2 的用法</h3> <p># 1.简介<br /> MongoDB是一个开源的文档型数据库，它提供了高性能，高可用性，<a href="https://en.wikipedia.org/wiki/Autoscaling">自动伸缩</a>等特性。MongoDB可以不需要使用ORM(Object Relational Mapping)来做开发。</p> <h1 id="documents">2.文档(Documents)</h1> <p>一条MongoDB的记录就是指一个文档，它是指一种由键值对组成的数据结构，有点类似于JSON 对象。文档中的值可以是其他文档，或是数组，或是由许多文档组成的文档数组。<br /> 示例如下：</p><pre><code>  
    {  
       "_id" : ObjectId("54c955492b7c8eb21818bd09"),  
       "address" : {  
          "street" : "2 Avenue",  
          "zipcode" : "10075",  
          "building" : "1480",  
          "coord" : [ -73.9557413, 40.7720266 ]  
       },  
       "borough" : "Manhattan",  
       "cuisine" : "Italian",  
       "grades" : [  
          {  
             "date" : ISODate("2014-10-01T00:00:00Z"),  
             "grade" : "A",  
             "score" : 11  
          },  
          {  
             "date" : ISODate("2014-01-16T00:00:00Z"),  
             "grade" : "B",  
             "score" : 17  
          }  
       ],  
       "name" : "Vella",  
       "restaurant_id" : "41704620"  
    }  
</code></pre><p># 3.集合(Collections)<br /> MongoDB将文档存在集合中，就像关系型数据库中一条一条数据存在表中一样。但是MongoDB集合和关系型数据库的表不一样，集合中的文档并不需要有相同的模式（就是不是每个文档中都有相同的字段）。</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id=""> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#)" width="1920" height="1200" xlink:href="img/20160301.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Sohu intern interview</h2> <p class="card__subtitle"></p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 2, 2016</span> </div> <h1 id="section">搜狐面试</h1> <p>这是的搜狐面试我的头一次面试，之前从来没有参加过任何互联网公司的面试，所有的面试经历也只是保研时候学校老师的面试，那时候也没具体问什么问题，只是问了一些数据结构的只是。<br /> 这次搜狐面试总体来说比较简单，两道问答题，一是问interface和abstract类有何区别，如何使用，第二是问HashMap和TreeMap的区别，HashMap算是比较基础，但是TreeMap我只回答了他的底层实现是红黑树，在任何情况下的查找效率都是相同的。但其实TreeMap除了继承AbstractMap之外，还实现了SortedMap的接口，这个使得TreeMap可以以某种实现了Compareable接口的类的规则来进行排序，保证TreeMap中key的有序。所以，在插入和删除，查找上，都是HashMap要优，但是在顺序遍历键，需要进行排序的时候，还是使用TreeMap。<br /> 接下来两道都是算法题，一道是判断扎金花谁会赢的问题，第二题是leetcode上的Best time to buy and sell stock的第一题。<br /> 扎金花我考虑到了“JQKA”这几个数没法使用ascii值得大小进行排序，使用了很多个判断来将“JQKA”来映射成为11，12，13，14，导致了我的代码几乎写了A4指的两面。我感觉这道题目主要是考虑条件的判断，因为其中有豹子/顺子/对子的比较（居然没有同花），如果都是同一种类的那么还要判断谁的牌更大（判断种类过于繁杂，而且我没有时间去考虑是否能去优化），还有就是要考虑下数组越界的问题，最后做出来的时间复杂度因该是O(n)。<br /> Best time to buy and sell stock 则比较简单，只要维护一个全局最大的利润和一个进行到时间点i就抛出之前股票的局部最大利润，到最后只需要返回那个全局的最大利润即可。时间复杂度为O(n)，空间复杂度为O(1)。<a href="https://leetcode.com/discuss/48378/kadanes-algorithm-since-mentioned-about-interviewer-twists">详细解释请戳</a>,这个可以扩展到求Max subarray problem.</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="version-0-1-0"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#version-0-1-0)" width="1920" height="1200" xlink:href="img/20160210.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Wikidatadump Reader</h2> <p class="card__subtitle">version 0.1.0</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Feb 11, 2016</span> </div> <h1 id="wikidata-dump-reader">wikidata dump reader</h1> <p>由于做毕设的原因，需要用到wikidata的数据，我找了官网上的下载地址<a href="https://en.wikipedia.org/wiki/Database_dump">Wikidatadump</a>作为我使用的数据。</p> <p>由于这个datadump有60多个G，而且只是一个文件，为了获得其中的某一条wikidata的记录十分不方便，此外，在这个datadump中，还有许多我做毕设不需要的信息，把这些信息重新处理。</p> <p>因为这个是json格式的数据，我想如果我储存在mongodb中进行信息的检索可能会比较好。</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="my-first-blog"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#my-first-blog)" width="1920" height="1200" xlink:href="img/20160116.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Hello World!</h2> <p class="card__subtitle">My First Blog!</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Jan 16, 2016</span> </div> <h3 id="hello-world">Hello World</h3> <p>我的第一篇博客，以后要在这里记录我的学习内容。</p> </div> </div> </div> </div> <!-- /cards --> </div> </div> <!-- /container --> <!-- JS --> <script src="js/vendors/trianglify.min.js"></script> <script src="js/vendors/TweenMax.min.js"></script> <script src="js/vendors/ScrollToPlugin.min.js"></script> <script src="js/vendors/cash.min.js"></script> <script src="js/card-modern-blog.min.js"></script> <script src="js/modern-blog.min.js"></script> </body> </html>
