<!DOCTYPE html> <html lang="en" class="no-js"> <head> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>52saber</title> <meta name="description" content="Personal Blog" /> <meta name="keywords" content="Learning" /> <meta name="author" content="hwt" /> <link rel="shortcut icon" href="img/favicon.ico"> <link rel="stylesheet" type="text/css" href="css/normalize.css" /> <link rel="stylesheet" type="text/css" href="fonts/font-awesome-4.3.0/css/font-awesome.min.css" /> <link rel="stylesheet" type="text/css" href="css/modern-blog.min.css" /> <!--[if IE]> <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script> <![endif]--> <script> if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) { var root = document.getElementsByTagName('html')[0]; root.setAttribute('class', 'ff'); }; </script> </head> <body class="body"> <div class="container"> <header class="header"> <h1>Saber<span>个人学习博客.</span></h1> </header> <div class="content"> <!-- trianglify pattern container --> <div class="pattern pattern--hidden"></div> <!-- cards --> <div class="wrapper"> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="array操作"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#array操作)" width="1920" height="1200" xlink:href="img/20160416.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">leetcode总结篇2</h2> <p class="card__subtitle">array操作</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Apr 16, 2016</span> </div> <h2 id="array">关于对array的问题总结</h2> <p>### 0 调整格式<br /> 直到2016年4月16号，leetcode中array的题一共73题</p> <h3 id="section">1 查找</h3> <p>1.1 求数组中是否存在2/3/4个数，这些数的和为给定值（或者是求有多少组不重复的满足要求，或是下标是多少，或是最接近给定数的那一组）<br /> 1.2 如果数组中有一个数出现次数大于数组长度的1/2，求这个数<br /> 1.3 查找旋转数组中的最小值/最大值<br /> 1.4 在旋转数组中查找一个数（旋转矩阵不包含相同值/可能包含相同值）<br /> 1.5 给定一个数组，求第一个没出现的正整数<br /> 1.6 给定一个排序数组，找出某个数字的开始和结束的index<br /> 1.7 在数组重要插入一个数，求要插入的位置（如果有相同值，那么返回这个值的index）<br /> 1.8 给定一个数组，长度为n+1，范围为1-n，找出其中那个重复的值（287题 find the duplicate number）</p> <h3 id="section-1">2 排序</h3> <p>2.1 求两个排序数组的中位数<br /> 2.2 合并间隔（56题 merge intervals）<br /> 2.3 数组中只包含0 1 2 对其排序<br /> 2.4 有n个数字，范围从0-n，找出那个缺少的数字</p> <h3 id="section-2">3 子数组问题/组合问题</h3> <p>3.1 查找和最大的连续子数组<br /> 3.2 买股票1234<br /> 3.3 查找乘积最大的连续子数组<br /> 3.4 从一个乱序数组中，找出最长的连续元素<br /> 3.5 给定一个已经排序的数字数组，求其子数组种类<br /> 3.6 给定一个排序的数字数组和数字k，求加起来是k的组合有多少种（39题 combination sum）<br /> 3.7 一个排序数组的子序列有多少种</p> <h3 id="section-3">4 面积问题</h3> <p>4.1 给定一个int[] nums数组，求使(j-i)*min(nums[j], nums[i])最大的i，j值(11题container with most water)<br /> 4.2 42题 trapping rain water 不知道怎么描述成一般化问题<br /> 4.3 84题 largest rectangle in histogram 计算用数组表示的最大长方形面积</p> <h3 id="section-4">5 重复数字</h3> <p>5.1 判断一个数组是否包含重复数字<br /> 5.2 查找重复的元素并去掉它(在排序数组中/在未排序数组中)<br /> 5.3 给定数字k，看是否有重复数字的下标差比k小<br /> 5.4 判断一个数组的重复数字超过数组长度n/3的个数<br /> 5.5 一个长度为n+1的数组，数字范围为1-n，假设只有一个重复数字，找出那个重复的数字</p> <h3 id="section-5">6 数组旋转</h3> <p>6.1 把数组<code class="highlighter-rouge">[1,2,3,4,5,6,7]</code> 旋转为 <code class="highlighter-rouge">[5,6,7,1,2,3,4]</code><br /> 6.2 旋转二维数组（90/180/270度）</p> <h3 id="section-6">7 数组合并/移动</h3> <p>7.1 把数组中的0元素移到数组的最后（其他数字顺序不变）<br /> 7.2 合并两个已经排过序的数组<br /> 7.3 57题 insert interval</p> <h3 id="section-7">8 二维矩阵</h3> <p>8.1 查找二维字符矩阵相邻字符是否能组成给定字符串<br /> 8.2 生成螺旋矩阵（54题 spiral matrix）<br /> 8.3 二维数组由0/1组成，找出最大的，由一组成的长方形<br /> 8.4 给定一个数字二维矩阵，如果某个点为0，那么就把它的行和列都置为0，不用辅助空间<br /> 8.5 一个二维数组，每一行从左向右递增，每一列从上到下递增，在这个数组中找给定值</p> <h3 id="section-8">杂项</h3> <p>给定一个数，用一个int[]数组来表示它，并且求这个数加一之后，int[]数组如何变化<br /> 杨辉三角的生成<br /> 给定一个数组，计算除了自生，其他元素的乘积</p> <h2 id="array-1">通用的array处理方式</h2> <p>### 1 排序<br /> O(n)时间，O(n)空间：基数排序，基数排序，桶排序。其中基数排序和桶排序的区别就是基数排序必须要有10个桶（0-9）,桶排序可以随意应以桶的个数<br /> O(nlogn)时间，O(1)空间：快速排序，归并排序（原地归并，没看懂做法），堆排序（先建堆，再一个一个输出）<br /> O(n*n)时间，O(1)空间：插入排序，冒泡排序，希尔排序<br /> 其他排序：位图法（仅适用于数字最多出现一次，且范围较小的情况），<a href="http://blog.csdn.net/dm_vincent/article/details/7714519">拓扑排序</a> 2种方法实现（DFS 与 BFS）</p> <h3 id="section-9">2 查找—-二分法</h3> <p>对于线性数组的查找，如果能用到二分法查找，那么效率就已经很高了（O(logn)），前提是数组排好了序。前面1.8里的那道题，不是从数组下标考虑，而是从数组内部的值来考虑，进行了二分查找，是一道比较有意思的题目（打破常规思维）。<br /> 剩下的得看数组的特点来合理定制二分的策略，来保证要找的数在其中的某一边。</p> <h3 id="section-10">3 数组内部元素的排列组合问题</h3> <p>首先是连续子数组的最大和问题，<a href="http://www.geeksforgeeks.org/largest-sum-contiguous-subarray/">解法</a><br /> 当我把这个数组后一个向前面一个相加，然后数组a就变成了数组b，数组b的第i个值为数组a的前i个值得和，那么连续子数组的最大和问题就变成了买股票的第一题的形式，就是数组中最大值减去最小值的极值<br /> 剩下的数组元素组合问题，基本上都可以用backtracking解决（即穷举法）</p> <h3 id="section-11">4 面积问题</h3> <p>可以使用two pointer来从两边向中间计算面积<br /> 剩下的就只能见仁见智了</p> <h3 id="section-12">5 重复数字</h3> <p>最直观的：可以用hashset，记录之前没有重复的数字，当出现重复值，那么就说明有重复数字<br /> 另外就是复杂度比较高的排序了，排序之后如果有两个连续的值相同，说明有重复数字<br /> 剩下就得看给的数字数组的特点了，如数组有一个重复的数字个数超过了数组长度的一半，如5.5的情况，就用二分法来做<br /> 如果数字最大和最小差比较小的话，还能用位图法来做</p> <h3 id="section-13">6 数组的旋转</h3> <p>一维数组的旋转：设置start和end，然后两边从中间交换，如果是6.1的旋转的话，可以先旋转前一半，再旋转后一半，再旋转整个数组来做到（3次旋转）<br /> 二维数组的旋转：当然，如果用辅助空间的话，只需要把长的那一行交换到对应的宽的那一列去就行了，如果用O(1)空间来做的话，那么就相当于是把原来的矩阵从两个对角线分开，分成4个部分，每个部分交换到正确的位置，这样可以保证不使用额外空间。</p> <h3 id="section-14">总结</h3> <p>对数组的操作最主要还是要看数组内容的特点，然后根据特点来选择对应的方法，没有固定的万能解法。</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id=""> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#)" width="1920" height="1200" xlink:href="img/20160409.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">对于manacher算法的一些思考</h2> <p class="card__subtitle"></p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Apr 8, 2016</span> </div> <h4 id="section">一些看法</h4> <p>网上也看了一些manacher的实现，感觉实现起来有点难，自己写代码的时候也有点磕磕绊绊。</p> <p>这个算法主要思想就是使用更大的容量，将计算回文需要考虑的回文长度的奇偶性全部处理为只要考虑奇数长度的。<br /> 如回文<code class="highlighter-rouge">abba</code> 将其扩充为 <code class="highlighter-rouge">#a#b#b#a#</code> ，这样就只考虑奇数长度的回文即可。<br /> 计算得到扩充后字符串中以每个字符为中点的最大回文长度半径（包括自身）为<code class="highlighter-rouge">[1, 2, 1, 2, 5, 2, 1, 2, 1]</code> ,将其全部减一之后就是以该点为中点， 得到的最长回文字串。<br /> 当然我们还可以使用之前计算好的值， 来保证这个算法的时间复杂度为O(n)时间<br /> 如果我们知道了上一个能够覆盖到最远距离的字符， 那么我们就能知道这个最远距离能够覆盖到字符串的第right位，<br /> 而且我们可以知道这个最远的字符在字符串的第idx位，</p> <p>1.那么我们在求第i个字符的最大回文长度的时候（i &gt; idx），我们就可以知道这个时候最短的回文长度和2*idx-i这个点（和idx对称的那个点）的一样长<br /> 2.如果由对称点推断出的i的最短回文长度无法覆盖到right时，我们就可以知道i点的最大回文长度就为其对称点的最大回文长度；<br /> 3.如果i点可以覆盖到right时，说明最大回文长度可能更长，<br /> 4.如果更长，那么新的idx就为当前点i，right也重新更新为新的right点，<br /> 5.如果没有更长，那么i点的最大回文长度就为其对称点的最大回文长度，不跟新idx与right（选择覆盖范围最大的，包含right的idx）<br /> 6.计算下一个i+1的最长回文长度</p> <p>这样保证了在所有循环计算点i的最大回文长度时，每个right点只被计算了1次，其他也没有影响效率的操作了，可以得出O(n)的时间复杂度。<br /> 下面贴出我写的萌萌哒代码（和网上的不太一样，别人的更简练，我这个思路还算清晰）</p><pre><code>  
public int[] helper(String ss) {  
    	int[] ans = new int[ss.length()];  
    	ans[0] = 1;  
    	int id = 0;  
    	int right = 0;  
    	for(int i = 1; i &lt; ans.length; i++) {  
    		int radius = 1;  
    		if(i &lt; right &amp;&amp; ans[2*id-i]+i-1 &lt; right) {   
    			ans[i] = ans[2*id-i];  
    			continue;  
    		}else if(i &lt; right &amp;&amp; 2*id-i &gt;= 0 &amp;&amp; ans[2*id-i]+i-1 == right) {  
    			radius = ans[2*id-i];  
    		}  
    		while(i-radius &gt;= 0 &amp;&amp; i+radius &lt;ans.length &amp;&amp; ss.charAt(i+radius) == ss.charAt(i-radius)) {  
    			radius++;  
    		}    
    		ans[i] = radius;  
    		if(2*id-i &gt;= 0 &amp;&amp; radius == ans[2*id-i]) {  
    			continue;  
    		}  
    		right = i+radius-1;  
    		id = i;  
    	}  
    	return ans;  
    }  
</code></pre></div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="字符串操作"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#字符串操作)" width="1920" height="1200" xlink:href="img/20160329.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">leetcode总结篇1</h2> <p class="card__subtitle">字符串操作</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 29, 2016</span> </div> <h2 id="string">关于对String的问题总结</h2> <p>### 0 调整格式<br /> 下次不写那么长的了，jekyll的markdown解析器太弱了</p> <h3 id="section">1.（在满足一定条件下）最长/短子字符串问题</h3> <p>1.1 子字符串中没有重复的字符的最长子串<br /> 1.2 子字符串是个回文字符串的最长子串<br /> 1.3 子字符串是给定所有字符串的公共前缀的最长子串<br /> 1.4 子字符串满足括号的合法性的最长子串<br /> 1.5 子字符串包含所有给定字符的最短子串<br /> 1.6 以给定字符串为基础，构建最短回文字符串， 即该字符串中的一段为给定字符串</p> <h3 id="section-1">2.（在不同规则下）字符串的加减乘问题</h3> <p>2.1 字符串的相乘<br /> 2.2 字符串表示二进制加法<br /> 2.3 实现一个计算器，字符串给的是计算公式</p> <h3 id="section-2">3.字符串的转换问题</h3> <p>3.1 字符串转Integer（即实现atoi函数）<br /> 3.2 字符串和罗马数字的相互转换<br /> 3.3 字符串加密解密（简单映射）<br /> 3.4 数字转英文（转换后的为英语口语念这段数字）</p> <h3 id="section-3">4.字符串的重排序问题</h3> <p>4.1 把字符串按照‘之’字形进行排列<br /> 4.2 把一个字符串数组中的字符串按顺序放到许多行长度为L的空字符串中，字符串与字符串之间的空格数量要基本相同<br /> 4.3 反转字符串（全部反转，反转一部分，反转单词）</p> <h3 id="section-4">5.字符串匹配问题</h3> <p>5.1 正则表达式只包含“ . ” “ * ”两个字符<br /> 5.2 给定一个字典和一个字符串，找出字符串中某一段，与字典中的所有字符串都串起来相同<br /> 5.3 给定一个unix下的用字符串表示的路径，将其简化（其中可能有./ ../ ///）</p> <h3 id="section-5">6.字符串的排列组合问题</h3> <p>6.1 手机电话键盘输入的一串数字，有多少种字符的排列组合<br /> 6.2 给定一定数量的括号，有多少种括号的排列组合满足括号的合法性<br /> 6.3 把有同一个字符有相同数量的字符串整合到一个数组中<br /> 6.4 查看两个字符串的编辑距离是否为1（只修改1次就可以把一个字符串变为另一个字符串），或计算两个字符串的编辑距离<br /> 6.5 字符串内部顺序交换（87题） <br /> 6.6 给定一个ip（字符串表示，没有“.”），求可以表示多少种ip<br /> 6.7 两个字符串组成一个新的字符串，保证新字符串中的字符在原先字符串中的顺序不变<br /> 6.8 （和6.7类似）一个字符串，删掉一些字符，是否可以变成另一个字符串（有多少种删除方式）<br /> 6.9 给定两个字符串和一个字典，每次可以改变字符串的其中一个字母（但新改变的必须要在字典之中），几次（有几种方式）可以转变为目标字符串</p> <h3 id="section-6">7.杂项</h3> <p>7.1 字符串是否可以表示成一个数字（数字可能用科学记数法表示）<br /> 7.2 字符串是否是回文（其中某些字符不在判断之列，如空格）<br /> 7.3 对比用string表示的版本号</p> <h3 id="section-7">通用的字符串的处理方式</h3> <h3 id="section-8">1. 对回文的处理</h3> <p>一般来做也就是从中间向两边扩展的做法，但是还有一个manacher算法，可以用线性时间来计算每个点的最大回文长度，思想就是把最大回文长度从奇数或偶数全变为了奇数，再利用了之前的计算回文长度的信息，这样就保证在O(n)时间内计算得到所有点的最大回文长度。<br /> <a href="http://blog.csdn.net/xn4545945/article/details/38795531">计算回文4中方法总结</a><br /> <a href="http://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/">manacher算法1</a><br /> <a href="http://www.geeksforgeeks.org/longest-palindromic-substring-set-2/">manacher算法2</a></p> <h3 id="section-9">2. 字符串的加减乘除处理，和数字的合法性</h3> <p>2.1 首先要处理这个字符串是否能够表示成一个数字，有些可能在最前面有很多个0，那样是不合法的<br /> 2.2 接着要处理数字符号，+/-号，最后结果可能是-号<br /> 2.3 加法就要考虑当前相加位数和进位的数值，当这3个都为0，且超过了最大数的位数时才停止计算<br /> 2.4 乘法就是多个加法相加，感觉也没有其他什么好方法<br /> 2.5 给定一个计算公式来计算这个公式的值，那么不光需要记录当前的符号，也需要记录上一个符号，以及上一个数字， 这样当遇到当前符号优先级比上一个符号要高的时候，就回退。<br /> 比如我计算3+5<em>6</em>8，首先记录符号+，和相加之后的值8，和之前的一个操作数5，当下一个符号是<em>时，那么就回退， 得到之前符号+，相加值33，之前一个操作数30（5</em>6），乘号的话为优先级最高的符号，计算完之后可以不保留。<br /> 如果遇到括号，那么可以用递归的方式，把他丢到一个函数里去处理，最后返回这个括号里计算得到的值，这样处理可以 解决多个括号的问题。当然，在最开始需要验证括号是否都有匹配上。</p> <h3 id="section-10">3. 字符串转换</h3> <p>找规律，然后做映射</p> <h3 id="section-11">4. 字符串重排序</h3> <p>4.1 找规律，然后将source字符串放入target字符串<br /> 4.2 可以用贪心算法，每次在满足条件下，放入最多个字符串<br /> 4.3 一次旋转的话就直接交换对应字符所在位置，如果把abcdef旋转为defabc，那么可以使用3次旋转的方式对其做出改变，ba=(a’b’)’</p> <h3 id="section-12">5. 正则表达式匹配</h3> <p>不会好方法，正在学习</p> <h3 id="section-13">6. 字符串的排列组合</h3> <p>6.1 最直观的：backtracking，可以获得所有的排列组合，也可以用二进制来做，但是这样做会有重复， 6.2 edit distance编辑距离，使用动态规划会比较好做，之后在动态规划里再讲这个。（如72题）<br /> 6.3 一般两个字符串合成为另一个更长的字符串问题，可以使用双指针，一个指向字符串1的头，一个指向另一个字符串的头， 看哪个符合要求，就让那个字符串的指针向后移。<br /> 6.4 当字符串变化是，假如说一次只变化其中一个字符，一般用BFS来储存这个字符串到底能变成多少种其他字符串， 这样可以用最少的变化次数变为目标字符串。（如word ladder）<br /> 6.5 当判断组成两个字符串的字符是否相同时，1.可以用hashmap来做，2.可以将两个字符串排序，看其是否相同。</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id=""> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#)" width="1920" height="1200" xlink:href="img/20160323.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">阿里校招问题汇总!</h2> <p class="card__subtitle"></p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 23, 2016</span> </div> <h3 id="section">问题汇总</h3> <p>阿里校招电面难度还是有点高，作为一个为怎么好好学习java的人，问的一半问题我都没回答出来（或没回答好），本来想引导一下面试官，让他向基础的leetcode类型算法问，但是一个算法题都没问。</p> <ol> <li>自我介绍</li> <li>项目介绍</li> <li>项目中用的那些技术，你的工作部分是哪些</li> <li>ssh哪些模块，都用过哪些</li> <li>aop和ioc原理</li> <li>数据库引擎种类</li> <li>数据库引擎底层如何实现</li> <li>数据库索引种类及内部实现</li> <li>Hashmap底层实现</li> <li>堆栈溢出种类</li> <li>线程进程区别</li> <li>多线程如何死锁</li> <li>concurrent包看过哪些（concurrentHashMap）</li> <li>http协议报头组成</li> <li>斗鱼弹幕爬虫项目</li> <li>jvm垃圾回收算法</li> <li>分布式（直接说不会）</li> <li>struts和spring区别</li> </ol> <h1 id="section-1">03-24 更新2面</h1> <ol> <li>介绍一下自己遇到过，解决过最难的问题</li> <li>算法题<br /> 2.1 快速排序算法在最好的时间复杂度和最坏的时间复杂度 2.2 一个乱序数组，怎么知道其中两个数之和等于给定的值（O(n)时间，O(n)空间做法。。。O(nlogn)时间做法） 2.3 50个红球，50个白球，2个罐子（容量100），怎么放这些球，使得摸到红球的几率最大(数学题)。</li> <li>又问了一遍GC</li> <li>还有什么想问的（我把张浩在解决的那个bug问了他）。</li> </ol> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="翻译"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#翻译)" width="1920" height="1200" xlink:href="img/20160303.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Use MongoDB 3.2 in java</h2> <p class="card__subtitle">翻译</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 3, 2016</span> </div> <h3 id="mongodb-32-">MongoDB 3.2 的用法</h3> <p># 1.简介<br /> MongoDB是一个开源的文档型数据库，它提供了高性能，高可用性，<a href="https://en.wikipedia.org/wiki/Autoscaling">自动伸缩</a>等特性。MongoDB可以不需要使用ORM(Object Relational Mapping)来做开发。</p> <h1 id="documents">2.文档(Documents)</h1> <p>一条MongoDB的记录就是指一个文档，它是指一种由键值对组成的数据结构，有点类似于JSON 对象。文档中的值可以是其他文档，或是数组，或是由许多文档组成的文档数组。<br /> 示例如下：</p><pre><code>  
    {  
       "_id" : ObjectId("54c955492b7c8eb21818bd09"),  
       "address" : {  
          "street" : "2 Avenue",  
          "zipcode" : "10075",  
          "building" : "1480",  
          "coord" : [ -73.9557413, 40.7720266 ]  
       },  
       "borough" : "Manhattan",  
       "cuisine" : "Italian",  
       "grades" : [  
          {  
             "date" : ISODate("2014-10-01T00:00:00Z"),  
             "grade" : "A",  
             "score" : 11  
          },  
          {  
             "date" : ISODate("2014-01-16T00:00:00Z"),  
             "grade" : "B",  
             "score" : 17  
          }  
       ],  
       "name" : "Vella",  
       "restaurant_id" : "41704620"  
    }  
</code></pre><p># 3.集合(Collections)<br /> MongoDB将文档存在集合中，就像关系型数据库中一条一条数据存在表中一样。但是MongoDB集合和关系型数据库的表不一样，集合中的文档并不需要有相同的模式（就是不是每个文档中都有相同的字段）。</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id=""> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#)" width="1920" height="1200" xlink:href="img/20160301.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Sohu intern interview</h2> <p class="card__subtitle"></p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Mar 2, 2016</span> </div> <h1 id="section">搜狐面试</h1> <p>这是的搜狐面试我的头一次面试，之前从来没有参加过任何互联网公司的面试，所有的面试经历也只是保研时候学校老师的面试，那时候也没具体问什么问题，只是问了一些数据结构的只是。<br /> 这次搜狐面试总体来说比较简单，两道问答题，一是问interface和abstract类有何区别，如何使用，第二是问HashMap和TreeMap的区别，HashMap算是比较基础，但是TreeMap我只回答了他的底层实现是红黑树，在任何情况下的查找效率都是相同的。但其实TreeMap除了继承AbstractMap之外，还实现了SortedMap的接口，这个使得TreeMap可以以某种实现了Compareable接口的类的规则来进行排序，保证TreeMap中key的有序。所以，在插入和删除，查找上，都是HashMap要优，但是在顺序遍历键，需要进行排序的时候，还是使用TreeMap。<br /> 接下来两道都是算法题，一道是判断扎金花谁会赢的问题，第二题是leetcode上的Best time to buy and sell stock的第一题。<br /> 扎金花我考虑到了“JQKA”这几个数没法使用ascii值得大小进行排序，使用了很多个判断来将“JQKA”来映射成为11，12，13，14，导致了我的代码几乎写了A4指的两面。我感觉这道题目主要是考虑条件的判断，因为其中有豹子/顺子/对子的比较（居然没有同花），如果都是同一种类的那么还要判断谁的牌更大（判断种类过于繁杂，而且我没有时间去考虑是否能去优化），还有就是要考虑下数组越界的问题，最后做出来的时间复杂度因该是O(n)。<br /> Best time to buy and sell stock 则比较简单，只要维护一个全局最大的利润和一个进行到时间点i就抛出之前股票的局部最大利润，到最后只需要返回那个全局的最大利润即可。时间复杂度为O(n)，空间复杂度为O(1)。<a href="https://leetcode.com/discuss/48378/kadanes-algorithm-since-mentioned-about-interviewer-twists">详细解释请戳</a>,这个可以扩展到求Max subarray problem.</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="version-0-1-0"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#version-0-1-0)" width="1920" height="1200" xlink:href="img/20160210.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Wikidatadump Reader</h2> <p class="card__subtitle">version 0.1.0</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Feb 11, 2016</span> </div> <h1 id="wikidata-dump-reader">wikidata dump reader</h1> <p>由于做毕设的原因，需要用到wikidata的数据，我找了官网上的下载地址<a href="https://en.wikipedia.org/wiki/Database_dump">Wikidatadump</a>作为我使用的数据。</p> <p>由于这个datadump有60多个G，而且只是一个文件，为了获得其中的某一条wikidata的记录十分不方便，此外，在这个datadump中，还有许多我做毕设不需要的信息，把这些信息重新处理。</p> <p>因为这个是json格式的数据，我想如果我储存在mongodb中进行信息的检索可能会比较好。</p> </div> </div> </div> </div> <div class="card"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="my-first-blog"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#my-first-blog)" width="1920" height="1200" xlink:href="img/20160116.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Hello World!</h2> <p class="card__subtitle">My First Blog!</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/hwt.jpg" /> <span class="meta__author">hwt</span> <span class="meta__date">Jan 16, 2016</span> </div> <h3 id="hello-world">Hello World</h3> <p>我的第一篇博客，以后要在这里记录我的学习内容。</p> </div> </div> </div> </div> <!-- /cards --> </div> </div> <!-- /container --> <!-- JS --> <script src="js/vendors/trianglify.min.js"></script> <script src="js/vendors/TweenMax.min.js"></script> <script src="js/vendors/ScrollToPlugin.min.js"></script> <script src="js/vendors/cash.min.js"></script> <script src="js/card-modern-blog.min.js"></script> <script src="js/modern-blog.min.js"></script> </body> </html>
